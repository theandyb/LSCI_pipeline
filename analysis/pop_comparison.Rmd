---
title: "pop_comparison"
author: "Andy Beck"
date: "2025-01-20"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Introduction

In this document we are primarily interested in assessing the consistency of results across the five 1kGP super-populations. Namely, for the single position models:

1. Are the patterns of influence seen across positions shared across populations?
2. At individual positions, are the same nucleotides the most influential across populations?

The questions we ask for the two position models are similar.

Addendum:

* What differences might be interesting to suss out?
* What if we utilize our model framework to identify differences between the populations?
* Are "windows of significance consistent across populations?

## Setup and Data Functions

### Libraries

```{r}
library(tidyverse)
library(ggpubfigs) # functions for color blind friendly palettes
library(reactable) # table output for html
library(knitr) # PDF table output
library(corrr)
library(gtsummary)
library(MASS)

library(conflicted)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")

subtype_print_names <- function(st){
  if(str_starts(st, "AT")){
    return(paste0("A → ", str_sub(st, 4, 4)))
  } else if(str_starts(st, "GC")){
    return(paste0("C → ", str_sub(st, 5, 5)))
  } else{
    return(paste0("CpG → ", str_sub(st, 9, 9), "pG"))
  }
}

subtypes <- c("AT_CG", "AT_GC", "AT_TA",
              "GC_AT", "GC_TA", "GC_CG",
              "cpg_GC_AT", "cpg_GC_TA", "cpg_GC_CG")
```

### Single Position Functions

Load position-level results:

```{r}
# Load position-level statistics for a population-subtype pair
sp_deviance_df_load <- function(res_dir, pop, subtype){
  f_name <- paste0(res_dir, "/", pop, "/", subtype, ".csv")
  df <- read_csv(f_name, show_col_types = FALSE) %>%
    rowwise() %>%
    mutate(re = dev / (2 * (singletons+controls)),
           is_sig = dev > qchisq(0.05, df = 3, lower.tail = F))
  return(df)
}

# Same as above, but appends the population label (seems redundant?)
sp_re_single_pop <- function(res_dir, subtype, pop){
  df <- sp_deviance_df_load(res_dir, pop, subtype) %>%
    mutate(pop=pop)
}

sp_re_all_pop <- function(res_dir, subtype){
  df_ALL <- sp_re_single_pop(res_dir, subtype, "ALL")
  
  df_AFR <- sp_re_single_pop(res_dir, subtype, "AFR")
  
  df_AMR <- sp_re_single_pop(res_dir, subtype, "AMR")
  
  df_EAS <- sp_re_single_pop(res_dir, subtype, "EAS")
  
  df_EUR <- sp_re_single_pop(res_dir, subtype, "EUR")
  
  df_SAS <- sp_re_single_pop(res_dir, subtype, "SAS")
  
  #return(bind_rows(df_ALL, df_AFR, df_AMR, df_EAS, df_EUR, df_SAS) %>%
  #  pivot_wider(id_cols = offset, names_from = pop, values_from = re))
  return(bind_rows(df_ALL, df_AFR, df_AMR, df_EAS, df_EUR, df_SAS))
}

get_pos_cc <- function(control_control, pop, subtype){
  f_name <- paste0(control_control, "/", pop, "/", subtype, "_v2.csv")
  df <- read_csv(f_name, show_col_types = FALSE) %>%
           mutate(re = dev / (2 * (singletons + controls) ))
  return(df)
}

get_pos_cc_pops <- function(control_control, subtype){
  pops <- c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS")
  results <- vector("list", length(pops))
  names(results) <- pops
  for(p in pops){
    results[[p]] <- get_pos_cc(control_control, p, subtype)
    results[[p]]$pop <- p
  }
  return(bind_rows(results))
}
```

Load position-level residuals:

```{r}
sp_resid_df_load <- function(res_dir, pop, subtype, rp){
  # f_name <- paste0(res_dir, "/resid/", pop, "/", subtype, "_rp_", rp, ".csv")
  # df <- read_csv(f_name, show_col_types = FALSE)
  # df$rp <- rp
  # return(df)
  f_name <- paste0(res_dir, "/resid/", pop, "/", subtype, "_rp_", rp, ".csv")
  df <- read_csv(f_name, show_col_types = FALSE)
  df$rp <- rp
  
  n_tot <- sum(df$n)
  df$re_res <- (df$res^2) / (2*n_tot)
  return(df)
}

sp_resid_df_load_all <- function(res_dir, pop, subtype, rp = c(-500:-1, 1:500)){
  results <- vector(mode = "list", length = length(rp))
  for(i in 1:length(rp)){
    if(rp[i] == 1 & str_starts(subtype, "cpg")) next
    results[[i]] <- sp_resid_df_load(res_dir, pop, subtype, rp[i])
  }
  df <- bind_rows(results)
  return(df)
}

sp_resid_all_pop <- function(res_dir, subtype, rp = c(-500:-1, 1:500)){
  df_ALL <- sp_resid_df_load_all(res_dir, "ALL", subtype, rp) %>%
    select(rp, nuc, status, n, res, re_res) %>%
    mutate(pop = "ALL")
  
  df_AFR <- sp_resid_df_load_all(res_dir, "AFR", subtype, rp) %>%
    select(rp, nuc, status, n, res, re_res) %>%
    mutate(pop = "AFR")
  
  df_AMR <- sp_resid_df_load_all(res_dir, "AMR", subtype, rp) %>%
    select(rp, nuc, status, n, res, re_res) %>%
    mutate(pop = "AMR")
  
  df_EAS <- sp_resid_df_load_all(res_dir, "EAS", subtype, rp) %>%
    select(rp, nuc, status, n, res, re_res) %>%
    mutate(pop = "EAS")
  
  df_EUR <- sp_resid_df_load_all(res_dir, "EUR", subtype, rp) %>%
    select(rp, nuc, status, n, res, re_res) %>%
    mutate(pop = "EUR")
  
  df_SAS <- sp_resid_df_load_all(res_dir, "SAS", subtype, rp) %>%
    select(rp, nuc, status, n, res, re_res) %>%
    mutate(pop = "SAS")
  
  return(bind_rows(df_ALL, df_AFR, df_AMR, df_EAS, df_EUR, df_SAS))
}
```

Load population-population models:

```{r}
load_pop_pop_resid <- function(pop_pop_dir, pop1, pop2, subtype, rp){
  f_name <- paste0(pop_pop_dir, "/", pop1, "_", pop2, "/", subtype, "_rp_", rp, ".csv")
  df <- read_csv(f_name, show_col_types = FALSE)
  return(df)
}

pop_pop_dev <- function(pop_pop_dir, pop1, pop2, subtype, rp){
  df <- load_pop_pop_resid(pop_pop_dir, pop1, pop2, subtype, rp)
  dev_stat <- sum((df$res)^2)
  n_singletons <- df %>%
    filter(status == "singletons") %>%
    pull(n) %>%
    sum()
  n_controls <- df %>%
    filter(status == "singletons") %>%
    pull(n) %>%
    sum()
  re_val <- dev_stat / (2*(n_singletons + n_controls))
  is_sig <- dev_stat > qchisq(0.95, 3)
  return(data.frame(rp = rp, dev = dev_stat, re = re_val, singletons = n_singletons, controls = n_controls, is_sig = is_sig))
}

load_pop_pop_df <- function(pop_pop_dir, pop1, pop2, subtype, rps = c(-20:-1,1:20)){
  results <- vector(mode = "list", length = length(rps))
  for(i in 1:length(rps)){
    results[[i]] <- pop_pop_dev(pop_pop_dir, pop1, pop2, subtype, rps[i])
  }
  return(bind_rows(results))
}
```

Get all pairs of population-population correlation values for single position models:

```{r}
single_pos_resid_table <- function(single_pos_dir, restriced_range = 20){
  subtypes <- c("AT_CG", "AT_GC", "AT_TA",
                "GC_AT", "GC_TA", "GC_CG",
                "cpg_GC_AT", "cpg_GC_TA", "cpg_GC_CG")
  
  cor_types <- c("pearson", "spearman")
  
  pops <- c("AFR", "AMR", "EAS", "EUR", "SAS")
  pop_combs <- combn(pops,2)
  pops_df <- data.frame(pop1 = pop_combs[1,],
                        pop2 = pop_combs[2,])
  
  final <- data.frame(subtype = character(0), 
                      range = character(0),
                      res_type = character(0),
                      pop1 = character(0),
                      pop2 = character(0),
                      value = numeric(0))
  
  for(st in subtypes){
    df_res <- sp_re_all_pop(single_pos_dir, st)
    
    for(i in 1:length(pops_df$pop1)){
      pop1 <- pops_df$pop1[i]
      pop2 <- pops_df$pop2[i]
      df_res2 <- df_res %>%
        filter(pop == pop1 | pop == pop2) %>%
        select(offset, re, pop)
      
      for(ct in cor_types){
        # All positions
        value <- df_res2 %>%
          pivot_wider(id_cols = "offset", names_from = "pop", values_from = re) %>%
          {cor(.[,2], .[,3], method = ct)} %>%
          as.numeric()
        final <- bind_rows(final, 
                           data.frame(subtype = st, 
                                      range = "all", 
                                      res_type = ct, 
                                      pop1 = pop1, 
                                      pop2=pop2, 
                                      value = value))
        # +/- 20
        value <- df_res2 %>%
          filter(abs(offset) <= restriced_range) %>% 
          pivot_wider(id_cols = "offset", names_from = "pop", values_from = re) %>%
          {cor(.[,2], .[,3], method = ct)} %>%
          as.numeric()
        final <- bind_rows(final, 
                           data.frame(subtype = st, 
                                      range = "restricted", 
                                      res_type = ct, 
                                      pop1 = pop1, 
                                      pop2=pop2, 
                                      value = value))
      }
    }
  }
  return(final)
}
```


### Two position functions

```{r}
tp_deviance_df_load <- function(base_dir, pop, subtype){
  f_name <- paste0(base_dir, "/", pop, "/", subtype, ".csv")
  df <- read_csv(f_name, show_col_types = F, 
                 col_names = c("dev","singletons","controls","rp1","rp2")) %>%
    rowwise() %>%
    mutate(re = dev / (2 * (singletons + controls))) %>%
    ungroup()
  return(df)
}

tp_resid_df_load <- function(base_dir, pop, subtype, p, q){
  f_name <- paste0(base_dir, "/resid/", pop, "/", subtype, "_p", p, "_q", q, ".csv")
  df <- read_csv(f_name, show_col_types = F)
  return(df)
}
```

### Paths

```{r}
base_dir = "output"
single_pos_dir = paste0(base_dir, "/single_pos")
two_pos_dir = paste0(base_dir, "/two_pos")
control_control <- paste0(base_dir, "/single_pos_cc")
pop_pop_dir <- paste0(base_dir, "/single_pos_pp")
```

### Single Position Subtype Analysis Functions

```{r}
residual_analysis <- function(df_resid, subtype, no_plots = F){
  grouped_resid_df <- df_resid %>%
    filter(status == "singletons", pop != "ALL") %>%
    group_by(rp, nuc) %>%
    arrange(pop, rp, nuc)
  
  populations <- unique(grouped_resid_df$pop)
  
  
  corr_at_pos <- data.frame(rp = unique(grouped_resid_df$rp), 
                            AFR_AMR = 0,
                            AFR_EAS = 0,
                            AFR_EUR = 0,
                            AFR_SAS = 0,
                            AMR_EAS = 0,
                            AMR_EUR = 0,
                            AMR_SAS = 0,
                            EAS_EUR = 0,
                            EAS_SAS = 0,
                            EUR_SAS = 0)
  for(i in 1:length(corr_at_pos$rp)){
    df2 <- grouped_resid_df %>%
      filter(rp == corr_at_pos$rp[i]) %>%
      ungroup() %>%
      select(nuc, pop, res) %>%
      pivot_wider(names_from = pop, values_from = res)
    
    corr_at_pos$AFR_AMR[i] <- cor(df2$AFR, df2$AMR, method = "pearson")
    corr_at_pos$AFR_EAS[i] <- cor(df2$AFR, df2$EAS, method = "pearson")
    corr_at_pos$AFR_EUR[i] <- cor(df2$AFR, df2$EUR, method = "pearson")
    corr_at_pos$AFR_SAS[i] <- cor(df2$AFR, df2$SAS, method = "pearson")
    corr_at_pos$AMR_EAS[i] <- cor(df2$AMR, df2$EAS, method = "pearson")
    corr_at_pos$AMR_EUR[i] <- cor(df2$AMR, df2$EUR, method = "pearson")
    corr_at_pos$AMR_SAS[i] <- cor(df2$AMR, df2$SAS, method = "pearson")
    corr_at_pos$EAS_EUR[i] <- cor(df2$EAS, df2$EUR, method = "pearson")
    corr_at_pos$EAS_SAS[i] <- cor(df2$EAS, df2$SAS, method = "pearson")
    corr_at_pos$EUR_SAS[i] <- cor(df2$EUR, df2$SAS, method = "pearson")
  }
  
  df_pearson <- corr_at_pos
  
  for(i in 1:length(corr_at_pos$rp)){
    df2 <- grouped_resid_df %>%
      filter(rp == corr_at_pos$rp[i]) %>%
      ungroup() %>%
      select(nuc, pop, res) %>%
      pivot_wider(names_from = pop, values_from = res)
    
    corr_at_pos$AFR_AMR[i] <- cor(df2$AFR, df2$AMR, method = "spearman")
    corr_at_pos$AFR_EAS[i] <- cor(df2$AFR, df2$EAS, method = "spearman")
    corr_at_pos$AFR_EUR[i] <- cor(df2$AFR, df2$EUR, method = "spearman")
    corr_at_pos$AFR_SAS[i] <- cor(df2$AFR, df2$SAS, method = "spearman")
    corr_at_pos$AMR_EAS[i] <- cor(df2$AMR, df2$EAS, method = "spearman")
    corr_at_pos$AMR_EUR[i] <- cor(df2$AMR, df2$EUR, method = "spearman")
    corr_at_pos$AMR_SAS[i] <- cor(df2$AMR, df2$SAS, method = "spearman")
    corr_at_pos$EAS_EUR[i] <- cor(df2$EAS, df2$EUR, method = "spearman")
    corr_at_pos$EAS_SAS[i] <- cor(df2$EAS, df2$SAS, method = "spearman")
    corr_at_pos$EUR_SAS[i] <- cor(df2$EUR, df2$SAS, method = "spearman")
  }
  
  if(no_plots == F){
    corr_matrix <- expand.grid(pop1 = populations, pop2 = populations) %>%
      filter(pop1 != pop2) %>% 
      rowwise() %>%
      mutate(cor_val = cor(
        grouped_resid_df$res[grouped_resid_df$pop == pop1],
        grouped_resid_df$res[grouped_resid_df$pop == pop2],
        method = "pearson"
      )) %>%
      ungroup()
    
    p1 <- corr_matrix %>%
      filter(pop1 != "AFR", pop2 != "SAS") %>%
      rowwise() %>%
      mutate(pop1 = as.character(pop1), pop2 = as.character(pop2)) %>%
      mutate(cor_val = ifelse(pop2 > pop1, NA, cor_val)) %>%
      ggplot(aes(x = pop1, y = pop2, fill = cor_val)) +
      geom_tile() +
      scale_fill_distiller(palette = "Reds", na.value = "white", direction = 1, limits = c(0,1)) +
      theme_classic() +
      xlab("") +
      ylab("") +
      ggtitle(paste0(subtype_print_names(subtype), "; Pearson Correlation"))
    
    corr_matrix <- expand.grid(pop1 = populations, pop2 = populations) %>%
      filter(pop1 != pop2) %>% 
      rowwise() %>%
      mutate(cor_val = cor(
        grouped_resid_df$res[grouped_resid_df$pop == pop1],
        grouped_resid_df$res[grouped_resid_df$pop == pop2],
        method = "spearman"
      )) %>%
      ungroup()
    
    p2 <- corr_matrix %>%
      filter(pop1 != "AFR", pop2 != "SAS") %>%
      rowwise() %>%
      mutate(pop1 = as.character(pop1), pop2 = as.character(pop2)) %>%
      mutate(cor_val = ifelse(pop2 > pop1, NA, cor_val)) %>%
      ggplot(aes(x = pop1, y = pop2, fill = cor_val)) +
      geom_tile() +
      scale_fill_distiller(palette = "Reds", na.value = "white", direction = 1, limits = c(0,1)) +
      theme_classic() +
      xlab("") +
      ylab("") +
      ggtitle(paste0(subtype_print_names(subtype), "; Spearman Correlation"))
    
    p3 <- df_pearson %>% 
      pivot_longer(-rp, names_to = "pops", values_to = "cor") %>%
      separate(pops, into = c("pop1", "pop2"), sep = "_") %>%
      ggplot(aes(x = rp, y = cor)) + 
      geom_point() +
      ylim(c(0,1)) + 
      facet_grid(rows = vars(pop2), cols = vars(pop1)) +
      ggtitle(paste0(subtype_print_names(subtype), "; Pearson Correlation"))
    
    p4 <- corr_at_pos %>% 
      pivot_longer(-rp, names_to = "pops", values_to = "cor") %>%
      separate(pops, into = c("pop1", "pop2"), sep = "_") %>%
      ggplot(aes(x = rp, y = cor)) + 
      geom_point() +
      ylim(c(0,1)) + 
      facet_grid(rows = vars(pop2), cols = vars(pop1)) +
      ggtitle(paste0(subtype_print_names(subtype), "; Spearman Correlation"))
    
    return(list(p1 = p1, p2 = p2, p3 = p3, p4 = p4, df_spearman = corr_at_pos, df_pearson = df_pearson))
  }
  else {
    return(list(df_spearman = corr_at_pos, df_pearson = df_pearson))
  }
  
}

nuc_resid_plots <-function(subtype, rp = c(-5:-1, 1:5)){
  df_resid <- sp_resid_all_pop(single_pos_dir, subtype, rp = rp)
  
  df_resid$ID <- as.character(df_resid$rp)
  xlab <- as.character(min(df_resid$rp):max(df_resid$rp))
  df_resid$ID <- factor(df_resid$ID, levels = xlab)
  
  res_df2 <- df_resid %>%
    mutate(sign_re = sign(res) * re_res) %>%
    select(ID, nuc, pop, status, sign_re) %>%
    pivot_wider(names_from = status, values_from = sign_re) %>%
    mutate(re_cont = sign(singletons) * (abs(singletons) + abs(controls)))
  
  p <- res_df2 %>%
    ggplot(aes(x= ID, y = re_cont, fill = nuc)) +
    scale_x_discrete(labels = xlab, drop = FALSE) +
    geom_bar(position = "stack", stat = "identity") +
    scale_fill_manual(values =ggpubfigs::friendly_pals$nickel_five  ) +
    ylab("Relative Entropy") +
    theme_bw() +
    xlab(paste0("Relative Position: ", subtype_print_names(subtype))) +
    labs(fill = "") +
    theme(legend.position = "top") +
    theme_classic() +
    facet_wrap(vars(pop))
  
  return(p)
}

single_pos_analysis <- function(subtype, rp = c(-10:-1, 1:10), sig_frac = 5/10){
  df_res <- sp_re_all_pop(single_pos_dir, subtype)
  df_resid <- sp_resid_all_pop(single_pos_dir, subtype, rp = rp)
  df_cc <- get_pos_cc_pops(control_control, subtype)
  
  p <- df_res %>%
    filter(abs(offset) < 20) %>%
    mutate(pop = factor(pop, levels = c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS"))) %>%
    ggplot(aes(x = offset, y = dev, colour = pop)) +
    geom_point() +
    geom_line() +
    scale_colour_manual(values = friendly_pal("vibrant_seven")) +
    theme_classic() +
    labs(colour = "Population") +
    xlab("Relative Position") +
    ylab("Deviance")
  print(p)
  
  p <- p +
    ylab("Deviance (log 10)") + 
    scale_y_log10()
  print(p)
  
  p <- df_res %>%
    filter(abs(offset) < 20) %>%
    mutate(pop = factor(pop, levels = c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS"))) %>%
    ggplot(aes(x = offset, y = re, colour = pop)) +
    geom_point() +
    geom_line() +
    scale_colour_manual(values = friendly_pal("vibrant_seven")) +
    theme_classic() +
    labs(colour = "Population") +
    xlab("Relative Position") +
    ylab("Relative Entropy")
  print(p)
  
  p <- p +
    ylab("Relative Entropy (log10)") +
    scale_y_log10()
  print(p)
  
  p <- df_res %>%
    mutate(pop = factor(pop, levels = c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS"))) %>%
    ggplot(aes(x = offset, y = re, colour = pop)) +
    geom_point(alpha = 0.5) +
    scale_colour_manual(values = friendly_pal("vibrant_seven")) +
    theme_classic() +
    labs(colour = "Population") +
    xlab("Relative Position") +
    ylab("Relative Entropy")
  print(p)
  
  p <- p +
    ylab("Relative Entropy (log10)") +
    scale_y_log10()
  print(p)
  
  # df_resid$ID <- as.character(df_resid$rp)
  # xlab <- as.character(min(df_resid$rp):max(df_resid$rp))
  # df_resid$ID <- factor(df_resid$ID, levels = xlab)
  # 
  # res_df2 <- df_resid %>%
  #   mutate(sign_re = sign(res) * re_res) %>%
  #   select(ID, nuc, pop, status, sign_re) %>%
  #   pivot_wider(names_from = status, values_from = sign_re) %>%
  #   mutate(re_cont = sign(singletons) * (abs(singletons) + abs(controls)))
  # 
  # p <- res_df2 %>%
  #   ggplot(aes(x= ID, y = re_cont, fill = nuc)) +
  #   scale_x_discrete(labels = xlab, drop = FALSE) +
  #   geom_bar(position = "stack", stat = "identity") +
  #   scale_fill_manual(values =ggpubfigs::friendly_pals$nickel_five  ) +
  #   ylab("Relative Entropy") +
  #   theme_bw() +
  #   xlab(paste0("Relative Position: ", subtype_print_names(subtype))) +
  #   labs(fill = "") +
  #   theme(legend.position = "top") +
  #   facet_wrap(vars(pop))
  
  cat("Correlation of RE statistics across all flanking positions +/- 1000 bp:\n")
  df_res %>%
    select(-is_sig) %>%
    pivot_wider(id_cols = offset, names_from = pop, values_from = re) %>%
    correlate(method = "pearson", diagonal = 1) %>%
    focus(-offset, mirror = T) %>%
    shave() %>%
    fashion() %>%
    print()
  
  df_res %>%
    select(-is_sig) %>%
    pivot_wider(id_cols = offset, names_from = pop, values_from = re) %>%
    correlate(method = "spearman", diagonal = 1) %>%
    focus(-offset, mirror = T) %>%
    shave() %>%
    fashion() %>%
    print()
  
  cat("Correlation of RE statistics across all flanking positions +/- 20 bp:\n")
  df_res %>%
    filter(abs(offset) < 20) %>%
    select(-is_sig) %>%
    pivot_wider(id_cols = offset, names_from = pop, values_from = re) %>%
    correlate(method = "pearson", diagonal = 1) %>%
    focus(-offset, mirror = T) %>%
    shave() %>%
    fashion() %>%
    print()
  
  df_res %>%
    filter(abs(offset) < 20) %>%
    select(-is_sig) %>%
    pivot_wider(id_cols = offset, names_from = pop, values_from = re) %>%
    correlate(method = "spearman", diagonal = 1) %>%
    focus(-offset, mirror = T) %>%
    shave() %>%
    fashion() %>%
    print()
  
  df_wide <- df_res %>%
    select(-is_sig) %>%
    pivot_wider(id_cols = offset, names_from = pop, values_from = re)
  
  nms <- combn(names(df_wide %>% select(-offset, -ALL)), 2, simplify = T) %>% 
    t() %>% 
    as.data.frame() %>% rename(x = V1, y = V2)
  
  plts <- map2(.x = nms$x, 
               .y = nms$y,
            ~{ggplot(data = df_wide, 
                     aes(x = .data[[.x]], 
                                y = .data[[.y]])) +
                geom_point()}
            )
  
  print(gridExtra::grid.arrange(grobs = plts))
  
  df_resid %>%
    pivot_wider(id_cols = rp:status, names_from = pop, values_from = res) %>%
    select(ALL:SAS) %>%
    correlate(method = "pearson", diagonal = 1) %>%
    shave() %>%
    fashion(decimals = 3) %>%
    print()
  
  df_resid %>%
    pivot_wider(id_cols = rp:status, names_from = pop, values_from = res) %>%
    select(ALL:SAS) %>%
    correlate(method = "spearman", diagonal = 1) %>%
    shave() %>%
    fashion(decimals = 3) %>%
    print()
  
  resid_plots <- residual_analysis(df_resid, subtype)

  print(resid_plots$p1)
  print(resid_plots$p2)
  print(resid_plots$p3)
  print(resid_plots$p4)
}

```

### Load all single position position-level statistics

```{r}
subtypes <- c("AT_CG", "AT_GC", "AT_TA",
              "GC_AT", "GC_TA", "GC_CG",
              "cpg_GC_AT", "cpg_GC_TA", "cpg_GC_CG")

load_all_pos_results <- function(result_dir, subtypes){
  final <- sp_re_all_pop(result_dir, subtypes[1]) %>%
    mutate(subtype = subtypes[1])
  
  for(i in 2:length(subtypes)){
    final <- final %>%
      bind_rows({
        sp_re_all_pop(result_dir, subtypes[i]) %>%
          mutate(subtype = subtypes[i])
      })
  }
  return(final)
}

df_all_sp <- load_all_pos_results(single_pos_dir, subtypes)
```

### Load all control-control single position results

```{r}
load_all_sp_cc <- function(control_contol, subtypes){
  final <- get_pos_cc_pops(control_control, subtypes[1]) %>%
    mutate(subtype = subtypes[1])
  
  for(i in 2:length(subtypes)){
    final <- final %>%
      bind_rows({
        get_pos_cc_pops(control_control, subtypes[i]) %>%
          mutate(subtype = subtypes[i])
      })
  }
  return(final)
}

df_all_sp_cc <- load_all_sp_cc(control_control, subtypes)
```

#### Aside: plot densities of position-level results

```{r}
df_all_sp %>%
  filter(subtype == "AT_GC") %>%
  ggplot(aes(x = pop, y = log10(dev))) +
  geom_boxplot(notch = TRUE) +
  geom_hline(yintercept = log10(qchisq(0.95, 3)), colour = "red")

df_all_crit <- df_all_sp %>%
  filter(subtype == "AT_GC") %>%
  group_by(pop) %>%
  summarize(mean_n = mean(2 * (singletons + controls)), 
            emp_re = quantile(re, 0.95)) %>%
  mutate(crit_re = qchisq(0.95, 3) / mean_n)

df_crit_cc <- df_all_sp_cc %>%
  filter(subtype == "AT_GC") %>%
  group_by(pop) %>%
  summarise(mean_n = mean(2*(singletons + controls)),
            emp_crit = quantile(re, 0.95)) %>%
  mutate(crit_re = qchisq(0.95, 3) / mean_n)

df_all_sp %>%
  filter(subtype == "AT_GC") %>%
  ggplot(aes(x = pop, y = re )) +
  geom_boxplot(notch = TRUE) +
  scale_y_log10() +
  geom_crossbar(data = df_all_crit, aes(x = pop, y = crit_re, ymin = crit_re, ymax = crit_re, color = type),
                colour = "salmon", linewidth = 0.5, width = 0.5) +
  geom_crossbar(data = df_crit_cc, aes(x = pop, y = emp_crit, ymin = emp_crit, ymax = emp_crit, color = type),
                colour = "green", linewidth = 0.5, width = 0.5)

df_crit_cc <- df_all_sp_cc %>%
  filter(subtype == "AT_GC") %>%
  group_by(pop) %>%
  summarise(emp_crit = quantile(dev, 0.95)) %>%
  right_join(df_all_crit, by = "pop") %>%
  mutate(new_crit_re = emp_crit / mean_n)

df_all_sp %>%
  filter(subtype == "AT_GC") %>%
  ggplot(aes(x = pop, y = re )) +
  geom_boxplot(notch = TRUE) +
  scale_y_log10() +
  geom_crossbar(data = df_all_crit, aes(x = pop, y = crit_re, ymin = crit_re, ymax = crit_re, color = type),
                colour = "salmon", linewidth = 0.5, width = 0.5) +
  geom_crossbar(data = df_crit_cc, aes(x = pop, y = new_crit_re, ymin = new_crit_re, ymax = new_crit_re, color = type),
                colour = "green", linewidth = 0.5, width = 0.5)
```


#### Aside: do each population's control-control results look similar?

```{r}
df_all_sp_cc %>%
  filter(subtype == "AT_GC") %>%
  ggplot(aes(x = pop, y = dev)) + 
  geom_boxplot(notch = TRUE) +
  xlab("Population") +
  ylab("Deviance") +
  geom_hline(yintercept = qchisq(0.95, 3), color = "red")

df_all_sp_cc %>%
  filter(subtype == "AT_GC") %>%
  ggplot(aes(x = dev, colour = pop)) +
  geom_density() +
  stat_function(
    fun = dchisq,
    args = list(df = 3),
    geom = "line",
    aes(colour = "Theoretical Chi-Square (df=3)", linetype = "Theoretical"),
    size = 1,
  ) +
  xlab("Deviance") +
  ylab("Density") +
  scale_colour_manual(
    name = "Population",
    values = c("blue", "red", "green", "purple", "orange", "magenta", "black"), # Customize colors as needed
    breaks = c(unique(df_all_sp_cc$pop), "Theoretical Chi-Square (df=3)")
  ) +
  scale_linetype_manual(
    name = "", # Remove the linetype legend title
    values = c("Theoretical" = "dotted"), # Set the theoretical line to dashed
    guide = "none" # Remove the linetype legend
  )

df_all_sp_cc %>%
  filter(subtype == "AT_GC") %>%
  ggplot(aes(x = pop, y = re)) + 
  geom_boxplot() +
  xlab("Population") +
  ylab("Relative Entropy")

df_all_sp_cc %>%
  filter(subtype == "AT_GC") %>%
  ggplot(aes(x = re, colour = pop)) + 
  geom_density() +
  xlab("Relative Entropy") +
  labs(colour = "Population")

# If we divide the chi square critical value by the mean number of 2*(singletons + controls) for each population:

df_crit_cc <- df_all_sp_cc %>%
  filter(subtype == "AT_GC") %>%
  group_by(pop) %>%
  summarise(mean_n = mean(2*(singletons + controls)),
            emp_crit = quantile(re, 0.95)) %>%
  mutate(crit_re = qchisq(0.95, 3) / mean_n)

df_all_sp_cc %>%
  filter(subtype == "AT_GC") %>%
  ggplot(aes(x = pop, y = re)) + 
  geom_boxplot(notch= TRUE) +
  xlab("Population") +
  ylab("Relative Entropy") +
  geom_crossbar(data = df_crit_cc, aes(x = pop, y = crit_re, ymin = crit_re, ymax = crit_re, color = type),
                colour = "salmon", size = 0.5, width = 0.5) +
  geom_crossbar(data = df_crit_cc, aes(x = pop, y = emp_crit, ymin = emp_crit, ymax = emp_crit, color = type),
                colour = "green", size = 0.5, width = 0.5)
  
## Last thing I want to check: if we divide the dev by mean_n, do we get distributions that look like re distributions?
df_all_sp_cc %>%
  filter(subtype == "AT_GC") %>%
  left_join(df_crit_cc, by = "pop") %>%
  mutate(re2 = dev / mean_n) %>%
  select(pop,offset, re, re2) %>%
  pivot_longer(starts_with("re"), names_to = "type", values_to = "re") %>%
  ggplot(aes(x = pop, y = re, colour = type)) +
  geom_boxplot(notch=T)
```

#### All subtypes for each population

```{r}
df_all_sp_cc %>%
  filter(pop == "SAS") %>%
  ggplot(aes(x = subtype, y = dev)) + 
  geom_boxplot(notch = TRUE) +
  xlab("Subtype") +
  ylab("Deviance") +
  ggtitle("All Subtypes", "Population: SAS") +
  geom_hline(yintercept = qchisq(0.95, 3), color = "red")
```


## Aside: Plot single position results along with control-control

```{r}
cc_re_95 <- df_all_sp %>%
  filter(subtype == "AT_CG", pop == "ALL") %>%
  left_join({df_all_sp_cc %>% 
      filter(pop == "ALL", subtype == "AT_CG") %>% 
      select(offset, dev) %>%
      rename(cc_dev = dev)}, 
      by = "offset") %>%
  mutate(cc_re = cc_dev / (2 * (singletons + controls)) ) %>%
  pull(cc_re) %>%
  quantile(0.95)

df_all_sp %>%
  filter(subtype == "AT_CG", pop == "ALL") %>%
  left_join({df_all_sp_cc %>% 
      filter(pop == "ALL", subtype == "AT_CG") %>% 
      select(offset, dev) %>%
      rename(cc_dev = dev)}, 
      by = "offset") %>%
  mutate(cc_re = cc_dev / (2 * (singletons + controls)) ) %>%
  ggplot(aes(x = offset, y = re, colour = is_sig)) +
  geom_point() +
  geom_point(aes(x = offset, y = cc_re, colour = "control"), alpha = 0.5) +
  scale_y_log10()


df_all_sp %>%
  filter(subtype == "AT_CG", pop == "ALL") %>%
  left_join({df_all_sp_cc %>% 
      filter(pop == "ALL", subtype == "AT_CG") %>% 
      select(offset, dev) %>%
      rename(cc_dev = dev)}, 
      by = "offset") %>%
  mutate(cc_re = cc_dev / (2 * (singletons + controls)) ) %>%
  ggplot(aes(x = offset, y = re, colour = is_sig)) +
  geom_point() +
  geom_hline(yintercept = cc_re_95) +
  scale_y_log10()

df_all_sp %>%
  filter(subtype == "AT_CG", pop == "ALL", abs(offset) > 450) %>%
  ungroup() %>%
  summarize(n_sig = sum(is_sig),
            n = n()) %>%
  mutate(fpr = n_sig / n)
```

## Find windows via chi square significance

```{r}
df <- df_all_sp %>%
  filter(subtype == "AT_CG", pop == "ALL") %>%
  arrange(offset)
```

Let's simply brute force this and see how many interior / exterior values are significant/insignificant as we consider expanding windows:

```{r}
df_results <- data.frame(size = numeric(),
                         tpr = numeric(),
                         fpr = numeric(),
                         tnr = numeric(),
                         fnr = numeric())

for(i in seq(10, 800, 10)){
  interior_vals <- df %>%
    filter(abs(offset) <= i) %>%
    pull(is_sig)
  
  exterior_vals <- df %>%
    filter(abs(offset) > i) %>%
    pull(is_sig)
  
  df_results <- bind_rows(df_results, 
                          data.frame(size = i,
                                     tpr = sum(interior_vals) / length(interior_vals),
                                     fpr = sum(!interior_vals) / length(interior_vals), 
                                     tnr = sum(!exterior_vals) / length(exterior_vals),
                                     fnr = sum(exterior_vals) / length(exterior_vals)))
}
```

And now let's plot these values:

```{r}
df_results %>%
  pivot_longer(-size, names_to = "type", values_to = "rate") %>%
  ggplot(aes(x = size, y = rate, colour = type)) +
  geom_point() +
  theme_classic() +
  xlab("Window Size") +
  ylab("Rate") +
  ggtitle("Fraction Interior/Exterior", paste0("Population: ", "ALL", "; Subtype: ", subtype_print_names("AT_CG"))) +
  geom_hline(aes(yintercept = 0.05, linetype = "a05")) +
  scale_linetype_manual(values = c("dotted")) +
  guides(linetype = "none")
```

How might we choose a good value for the window? Of the four metrics we compute, there are obvious trade-offs among them. Intuitively, we might want to base our decision on the number of interior values which are false positives (e.g. non-significant). If we control for this being at or below, say, 0.05. we would draw our boundary at 

```{r}
df_results %>%
  filter(fpr <= 0.05) %>%
  pull(size) %>%
  max()

df_results %>%
  filter(fnr >= 0.167) %>%
  pull(size) %>%
  max()

df_results %>%
  mutate(diff_false = fnr - fpr) %>%
  arrange(abs(diff_false)) %>%
  pull(size) %>% .[1]
```

And consequently, if we define our boundary at 290, the values for the other metrics we observe are:

```{r}
df_results %>% filter(size == 290) %>% knitr::kable()

df %>%
  rowwise() %>%
  mutate(is_sig2 = ifelse(is_sig, 
                          ifelse(abs(offset) <= 290, "tp", "fn" ), 
                          ifelse(abs(offset) <= 290, "fp", "tn" ))) %>%
  ungroup() %>%
  ggplot(aes(x = offset, y = re, colour = is_sig2)) +
  geom_point() +
  scale_y_log10() +
  geom_vline(aes(xintercept = -290, linetype = "bin")) +
  geom_vline(aes(xintercept = 290, linetype = "bin")) +
  scale_linetype_manual(values = c("dotted")) +
  scale_color_manual(values = ggpubfigs::friendly_pal("vibrant_seven", n=4)) +
  theme_classic() +
  guides(linetype = "none") +
  labs(colour = "Significance\n Type") +
  theme(legend.position = "inside",
        legend.position.inside = c(0.9, 0.8)) +
  ylab("Relative Entropy") +
  xlab("Offset") +
  ggtitle("0.05 False Positive Window", paste0("Population: ", "ALL", 
                                               "; Subtype: ", subtype_print_names("AT_CG"),
                                               "; Window: ", 290))
```

Great, now let's see what our results are if we apply this same criterion to all population-subtype pairs:

```{r}
window_finder_fp <- function(df_all_sp, st, p, alpha = 0.05){
  
  df <- df_all_sp %>%
    filter(subtype == st, pop == p) %>%
    arrange(offset)
  
  df_results <- data.frame(size = numeric(),
                         tpr = numeric(),
                         fpr = numeric(),
                         tnr = numeric(),
                         fnr = numeric())

  for(i in seq(10, 800, 10)){
    interior_vals <- df %>%
      filter(abs(offset) <= i) %>%
      pull(is_sig)
    
    exterior_vals <- df %>%
      filter(abs(offset) > i) %>%
      pull(is_sig)
    
    df_results <- bind_rows(df_results, 
                            data.frame(size = i,
                                       tpr = sum(interior_vals) / length(interior_vals),
                                       fpr = sum(!interior_vals) / length(interior_vals), 
                                       tnr = sum(!exterior_vals) / length(exterior_vals),
                                       fnr = sum(exterior_vals) / length(exterior_vals)))
  }
  
  p1 <- df_results %>%
    pivot_longer(-size, names_to = "type", values_to = "rate") %>%
    ggplot(aes(x = size, y = rate, colour = type)) +
    geom_point() +
    theme_classic() +
    xlab("Window Size") +
    ylab("Rate") +
    ggtitle("Fraction Interior/Exterior", paste0("Population: ", p, "; Subtype: ", subtype_print_names(st))) +
    geom_hline(aes(yintercept = 0.05, linetype = "a05")) +
    scale_linetype_manual(values = c("dotted")) +
    guides(linetype = "none")
  
  if(length(df_results %>%
    filter(fpr <= alpha) %>% pull(size)) > 0){
    win_size <- df_results %>%
      filter(fpr <= alpha) %>%
      pull(size) %>%
      max()
  } else {
    win_size <- df_results %>%
      filter(fpr > alpha) %>%
      pull(size) %>%
      min()
  }
  
  p2 <- df %>%
    rowwise() %>%
    mutate(is_sig2 = ifelse(is_sig, 
                            ifelse(abs(offset) <= win_size, "tp", "fn" ), 
                            ifelse(abs(offset) <= win_size, "fp", "tn" ))) %>%
    ungroup() %>%
    ggplot(aes(x = offset, y = re, colour = is_sig2)) +
    geom_point() +
    scale_y_log10() +
    geom_vline(aes(xintercept = -win_size, linetype = "bin")) +
    geom_vline(aes(xintercept = win_size, linetype = "bin")) +
    scale_linetype_manual(values = c("dotted")) +
    scale_color_manual(values = ggpubfigs::friendly_pal("vibrant_seven", n=4)) +
    theme_classic() +
    guides(linetype = "none") +
    labs(colour = "Significance\n Type") +
    theme(legend.position = "inside",
          legend.position.inside = c(0.9, 0.8)) +
    ylab("Relative Entropy") +
    xlab("Offset") +
    ggtitle(paste0(alpha, " False Positive Window"), paste0("Population: ", p, 
                                                 "; Subtype: ", subtype_print_names(st),
                                                 "; Window: ", win_size))
  
  return(list("figure" = p2, 
              "metrics" = df_results %>% filter(size == win_size),
              "rate_fig" = p1))
}

res_list <- window_finder_fp(df_all_sp, "AT_CG", "ALL")
```

```{r}
plot_list <- vector(mode = "list", length = 9)
names(plot_list) <- subtypes

plot_rate_list <- vector(mode = "list", length = 9)
names(plot_rate_list) <- subtypes

metric_list <- vector(mode = "list", length = 9)
names(metric_list) <- subtypes

for(i in subtypes){
  plot_list[[i]] <- vector(mode="list", length = 6)
  names(plot_list[[i]]) <- c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS")
  
  metric_list[[i]] <- vector(mode="list", length = 6)
  names(metric_list[[i]]) <- c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS")
  
  plot_rate_list[[i]] <- vector(mode="list", length = 6)
  names(plot_rate_list[[i]]) <- c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS")
}

for(i in subtypes){
  for(j in c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS")){
    print(paste0(i, " - ", j))
    res_item <- window_finder_fp(df_all_sp, i, j)
    
    metric_list[[i]][[j]] <- res_item$metrics %>% mutate(pop = j, subtype = i)
    plot_list[[i]][[j]] <- res_item$figure
    plot_rate_list[[i]][[j]] <- res_item$rate_fig
  }
}

df_metric <- metric_list %>% purrr::list_c() %>% bind_rows()
```

Now, let's explore these results:

### A > C

```{r}
st <- "AT_CG"

df_metric %>%
  filter(subtype == st) %>%
  knitr::kable()

plot_list[[st]][["ALL"]]
plot_list[[st]][["AFR"]]
plot_list[[st]][["AMR"]]
plot_list[[st]][["EAS"]]
plot_list[[st]][["EUR"]]
plot_list[[st]][["SAS"]]
```

### A > G

```{r}
st <- "AT_GC"

df_metric %>%
  filter(subtype == st) %>%
  knitr::kable()

plot_list[[st]][["ALL"]]
plot_list[[st]][["AFR"]]
plot_list[[st]][["AMR"]]
plot_list[[st]][["EAS"]]
plot_list[[st]][["EUR"]]
plot_list[[st]][["SAS"]]
```

### A > T

```{r}
st <- "AT_TA"

df_metric %>%
  filter(subtype == st) %>%
  knitr::kable()

plot_list[[st]][["ALL"]]
plot_list[[st]][["AFR"]]
plot_list[[st]][["AMR"]]
plot_list[[st]][["EAS"]]
plot_list[[st]][["EUR"]]
plot_list[[st]][["SAS"]]
```

### C > T

```{r}
st <- "GC_AT"

df_metric %>%
  filter(subtype == st) %>%
  knitr::kable()

plot_list[[st]][["ALL"]]
plot_list[[st]][["AFR"]]
plot_list[[st]][["AMR"]]
plot_list[[st]][["EAS"]]
plot_list[[st]][["EUR"]]
plot_list[[st]][["SAS"]]
```

### C > A

```{r}
st <- "GC_TA"

df_metric %>%
  filter(subtype == st) %>%
  knitr::kable()

plot_list[[st]][["ALL"]]
plot_list[[st]][["AFR"]]
plot_list[[st]][["AMR"]]
plot_list[[st]][["EAS"]]
plot_list[[st]][["EUR"]]
plot_list[[st]][["SAS"]]
```

### C > G

```{r}
st <- "GC_CG"

df_metric %>%
  filter(subtype == st) %>%
  knitr::kable()

plot_list[[st]][["ALL"]]
plot_list[[st]][["AFR"]]
plot_list[[st]][["AMR"]]
plot_list[[st]][["EAS"]]
plot_list[[st]][["EUR"]]
plot_list[[st]][["SAS"]]
```

### CpG > TpG

```{r}
st <- "cpg_GC_AT"

df_metric %>%
  filter(subtype == st) %>%
  knitr::kable()

plot_list[[st]][["ALL"]]
plot_list[[st]][["AFR"]]
plot_list[[st]][["AMR"]]
plot_list[[st]][["EAS"]]
plot_list[[st]][["EUR"]]
plot_list[[st]][["SAS"]]
```

### CpG > ApG

```{r}
st <- "cpg_GC_TA"

df_metric %>%
  filter(subtype == st) %>%
  knitr::kable()

plot_list[[st]][["ALL"]]
plot_list[[st]][["AFR"]]
plot_list[[st]][["AMR"]]
plot_list[[st]][["EAS"]]
plot_list[[st]][["EUR"]]
plot_list[[st]][["SAS"]]
```

### CpG > GpG

```{r}
st <- "cpg_GC_CG"

df_metric %>%
  filter(subtype == st) %>%
  knitr::kable()

plot_list[[st]][["ALL"]]
plot_list[[st]][["AFR"]]
plot_list[[st]][["AMR"]]
plot_list[[st]][["EAS"]]
plot_list[[st]][["EUR"]]
plot_list[[st]][["SAS"]]
```


## Inflection point analysis

The idea of this analysis is to smooth our log10(re) values over the offset, and based on this observed function identify inflection points that correspond to the "interesting region" in the center of the figure.

```{r}
df <- df_all_sp %>%
  filter(pop == "ALL", subtype == "AT_GC") %>%
  arrange(offset)
```

Let's first take a look at what the raw results look like:

```{r}
df %>%
  ggplot(aes(x = offset, y = log10(re), colour = is_sig)) +
  geom_point()
```

Now let's see what kind of smoothing options we have for this data:

```{r}
df %>%
  ggplot(aes(x = offset, y = log10(re))) +
  geom_point(aes(colour = is_sig)) +
  geom_smooth()

df %>%
  ggplot(aes(x = offset, y = log10(re))) +
  geom_point(aes(colour = is_sig)) +
  geom_smooth(method= "loess", span=0.15)

# df %>%
#   ggplot(aes(x = offset, y = re)) +
#   geom_point(aes(colour = is_sig)) +
#   geom_smooth()
```

On visual inspection, the default `gam` smoothed line looks like it has inflection points near positions where I would be tempted to draw lines to define the "region of interest". What other types of smoothing might I consider for this task?

### segmented Library

Let's see what happens when we fit the model log10(re) ~ offset using the `segmented` library. 

Open question: how do we go about choosing the number of segments?

```{r}
# library(segmented)
# 
# fit_lm <- lm(log10(re) ~ offset, data = df)
# fit_segmented <- segmented(fit_lm, seg.Z = ~offset, npsi = 10)
# 
# plot(fit_segmented)
# points(df)
# points.segmented(fit_segmented)
# 
# summary(fit_segmented)
```



## All Single Position RE Correlations

```{r}
# default restricted range is +/- 20 bp (inclusive)
df_cor <- single_pos_resid_table(single_pos_dir)

df_cor |> 
  pivot_wider(names_from = res_type, values_from = value) |>
  tbl_summary(include = c(pearson, spearman), 
              by = range, 
              statistic = all_continuous() ~ "{min}-{max} ({mean})")

df_cor |> 
  pivot_wider(names_from = res_type, values_from = value) |>
  tbl_strata(strata = subtype,
             .tbl_fun = 
               ~ .x |>
               tbl_summary(by = range, include = c(pearson, spearman),
                           statistic = all_continuous() ~ "{min}-{max} ({mean})"))
```

## All Single Position Residual Correlations

```{r}
res_cor_pearson <- vector("list", length(subtypes))
names(res_cor_pearson) <- subtypes

res_cor_spearman <- vector("list", length(subtypes))
names(res_cor_spearman) <- subtypes

for(st in subtypes){
  if(str_starts(st, "cpg")) rps <- c(-10:-1,2:10)
  else rps = c(-10:-1,1:10)
  df_resid <- sp_resid_all_pop(single_pos_dir, st, rp = rps)
  res_cor_analysis <- residual_analysis(df_resid, st, no_plots = T)
  
  res_cor_pearson[[st]] <- res_cor_analysis$df_pearson
  res_cor_spearman[[st]] <- res_cor_analysis$df_spearman
}

res_cor_pearson %>%
  bind_rows() %>%
  select(-rp) %>%
  summary() %>%
  knitr::kable()

res_cor_pearson %>%
  bind_rows() %>%
  select(-rp) %>%
  unlist() %>%
  summary() %>% t() %>%
  knitr::kable()

res_cor_spearman %>%
  bind_rows() %>%
  select(-rp) %>%
  summary() %>%
  knitr::kable()

res_cor_spearman %>%
  bind_rows() %>%
  select(-rp) %>%
  unlist() %>%
  summary() %>% t() %>%
  knitr::kable()
```

### Tables by Subtype

```{r results='asis'}
for(st in subtypes){
  cat(paste0("#### Subtype: ", st, "\n"))
  
  res_cor_pearson[[st]] %>%
    select(-rp) %>%
    summary() %>%
    knitr::kable() %>%
    print()
  
  cat("\n")
  
  res_cor_pearson[[st]] %>%
    select(-rp) %>%
    unlist() %>%
    summary() %>% t() %>%
    knitr::kable() %>%
    print()
  
  cat("\n")
  
  res_cor_spearman[[st]] %>%
    select(-rp) %>%
    summary() %>%
    knitr::kable() %>%
    print()
  
  cat("\n")
  
  res_cor_spearman[[st]] %>%
    select(-rp) %>%
    unlist() %>%
    summary() %>% t() %>%
    knitr::kable() %>%
    print()
  
  cat("\n")
  
}
```

## Shared Directionality of Nucleotide Level Residuals

```{r results='asis'}
for(st in subtypes){
  if(str_starts(st, "cpg")) rps <- c(-10:-1,2:10)
  else rps = c(-10:-1,1:10)
  df_resid <- sp_resid_all_pop(single_pos_dir, st, rp = rps)
  
  p <- df_resid |>
    filter(status == "singletons", pop != "ALL") |>
    select(pop, rp, nuc, res) |>
    group_by(rp, nuc) |>
    pivot_wider(names_from = pop, values_from = res) |>
    mutate(AFR_AMR = sign(AFR) == sign(AMR),
           AFR_EAS = sign(AFR) == sign(EAS),
           AFR_EUR = sign(AFR) == sign(EUR),
           AFR_SAS = sign(AFR) == sign(SAS),
           AMR_EAS = sign(AMR) == sign(EAS),
           AMR_EUR = sign(AMR) == sign(EUR),
           AMR_SAS = sign(AMR) == sign(SAS),
           EAS_EUR = sign(EAS) == sign(EUR),
           EAS_SAS = sign(EAS) == sign(SAS),
           EUR_SAS = sign(EUR) == sign(SAS)
           ) |>
    group_by(rp) |>
    summarize(AFR_AMR = sum(AFR_AMR),
              AFR_EAS = sum(AFR_EAS),
              AFR_EUR = sum(AFR_EUR),
              AFR_SAS = sum(AFR_SAS),
              AMR_EAS = sum(AMR_EAS),
              AMR_EUR = sum(AMR_EUR),
              AMR_SAS = sum(AMR_SAS),
              EAS_EUR = sum(EAS_EUR),
              EAS_SAS = sum(EAS_SAS),
              EUR_SAS = sum(EUR_SAS)) |>
    pivot_longer(-rp, names_to = "pops", values_to = "matches") |>
    separate_wider_delim(pops, delim = "_", names = c("pop1", "pop2")) |>
    ggplot(aes(x = rp, y = matches)) +
    geom_point() +
    ylim(c(0,4)) +
    facet_grid(rows = vars(pop2), cols = vars(pop1)) +
    xlab("Relative Position") +
    ylab("Nucleotides with Matching Sign") +
    ggtitle(st)
  print(p)
  
  ## For non-match, are these smaller in absolute value?
  test_nucleotides <- df_resid |>
    filter(status == "singletons", pop != "ALL") |>
    select(rp, nuc, pop, res) |>
    pivot_wider(names_from = pop, values_from = res) |>
    mutate(AFR_AMR = sign(AFR) == sign(AMR),
           AFR_EAS = sign(AFR) == sign(EAS),
           AFR_EUR = sign(AFR) == sign(EUR),
           AFR_SAS = sign(AFR) == sign(SAS),
           AMR_EAS = sign(AMR) == sign(EAS),
           AMR_EUR = sign(AMR) == sign(EUR),
           AMR_SAS = sign(AMR) == sign(SAS),
           EAS_EUR = sign(EAS) == sign(EUR),
           EAS_SAS = sign(EAS) == sign(SAS),
           EUR_SAS = sign(EUR) == sign(SAS)) %>%
    select(-AFR, -AMR, -EAS, -EUR, -SAS) |>
    pivot_longer(AFR_AMR:EUR_SAS, names_to = "pops", values_to = "match") |>
    filter(!match) |>
    separate_wider_delim(pops, delim = "_", names = c("pop1", "pop2"))
  
  df_resid_rank <- df_resid |>
    filter(status == "singletons", pop != "ALL") |>
    group_by(rp, pop) %>%
    mutate(nuc_rank = rank(abs(res)))
  
  test_nucleotides <- test_nucleotides %>%
    left_join(df_resid_rank, by = join_by(rp == rp, nuc == nuc, pop1 == pop)) %>%
    rename(rank1 = nuc_rank) |>
    left_join(df_resid_rank, by = join_by(rp == rp, nuc == nuc, pop2 == pop)) %>%
    rename(rank2 = nuc_rank)
  
  test_nucleotides |>
    select(rp, rank1, rank2) %>%
    pivot_longer(-rp, values_to = "rank") |>
    tbl_summary(include = rank) |>
    print()
}
```


## Single Position Results

### A > C

```{r}
subtype <- "AT_CG"
single_pos_analysis(subtype, sig_frac = 5/10)
```

```{r}
df_res <- sp_re_all_pop(single_pos_dir, subtype)
df_resid <- sp_resid_all_pop(single_pos_dir, subtype, rp = c(-10:-1, 1:10))
df_cc <- get_pos_cc_pops(control_control, subtype)
res_cor_analysis <- residual_analysis(df_resid, subtype)


df_res %>%
  filter(abs(offset) <= 20) %>%
  group_by(pop) %>%
  mutate(rank_re = dense_rank(desc(re))) %>%
  mutate(pop = factor(pop, levels = c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS"))) %>%
  filter(pop != "ALL") %>%
  ggplot(aes(x = rank_re, y = offset, colour = pop)) +
  geom_point(alpha = 0.5) +
  geom_line() +
  scale_colour_manual(values = friendly_pal("vibrant_seven")) +
  theme_classic() +
  labs(colour = "Population") +
  ylab("Relative Position") +
  xlab("Rank")
  
```


For the A > C subtype, we observe a high correlation of relative entropy statistics at the +/- 20

### A > G

```{r}
subtype <- "AT_GC"
single_pos_analysis(subtype)
```

### A > T

```{r}
subtype <- "AT_TA"
single_pos_analysis(subtype)
```

### C > T

```{r}
subtype <- "GC_AT"
single_pos_analysis(subtype)
```

### C > A

```{r}
subtype <- "GC_TA"
single_pos_analysis(subtype)
```

### C > G

```{r}
subtype <- "GC_CG"
single_pos_analysis(subtype)
```

### CpG > TpG

```{r}
subtype <- "cpg_GC_AT"
single_pos_analysis(subtype, rp = c(-10:-1,2:10))
```

### CpG > ApG

```{r}
subtype <- "cpg_GC_TA"
single_pos_analysis(subtype, rp = c(-10:-1,2:10))
```

### CpG > GpG

```{r}
subtype <- "cpg_GC_CG"
single_pos_analysis(subtype, rp = c(-10:-1,2:10))
```

## Single Position Nucleotide Residuals

### A > C

```{r fig.width=10, fig.height=8}
subtype <- "AT_CG"

nuc_resid_plots(subtype)
```

### A > G

```{r fig.width=10, fig.height=8}
subtype <- "AT_GC"

nuc_resid_plots(subtype)
```

### A > T

```{r fig.width=10, fig.height=8}
subtype <- "AT_TA"

nuc_resid_plots(subtype)
```

### C > T

```{r fig.width=10, fig.height=8}
subtype <- "GC_AT"

nuc_resid_plots(subtype)
```

### C > A

```{r fig.width=10, fig.height=8}
subtype <- "GC_TA"

nuc_resid_plots(subtype)
```

### C > G

```{r fig.width=10, fig.height=8}
subtype <- "GC_CG"

nuc_resid_plots(subtype)
```

### CpG > TpG

```{r fig.width=10, fig.height=8}
subtype <- "cpg_GC_AT"

nuc_resid_plots(subtype, rp = c(-5:-1, 2:5))
```

### C > A

```{r fig.width=10, fig.height=8}
subtype <- "cpg_GC_TA"

nuc_resid_plots(subtype, rp = c(-5:-1, 2:5))
```

### C > G

```{r fig.width=10, fig.height=8}
subtype <- "cpg_GC_CG"

nuc_resid_plots(subtype, rp = c(-5:-1, 2:5))
```

## Single Position Pop-Pop Model

In the following section, we utilize our log-linear model framework to assess consistency of single position model results by fitting models of the following form (in R's model notation):

```
glm(count ~ nuc*status + nuc*population + status*population, family = poisson())
```

Here, in contrast to our single population models, we allow for the distributions of nucleotides at flanking positions to differ between the singletons and the controls via the inclusion of a nucleotide-by-status interaction. The devinace statistic for this model evaluates the fit of this model to a fully-saturated model, in which in addition to the above terms is a three-way interaction between nucleotide, population, and status; under the null hypothesis that these parameters are 0, we assume that any nucleotide by status interaction is shared across the populations. Note that we fit these models for pairs of populations, so the degree of freedom for this test statistic is three (three two-way interactions between nucleotide and status, one population parameter to interact with).

```{r}
pop_combs <- combn(c("AFR", "AMR", "EAS", "EUR", "SAS"), 2) %>% t() 
```


### A > C

```{r}
subtype <- "AT_CG"

pop_pop_analysis <- function(pop_pop_dir, pop1, pop2, subtype, rps = c(-20:-1, 1:20)){
  df <- load_pop_pop_df(pop_pop_dir, pop1, pop2, subtype, rps)

  p <- df %>%
    ggplot(aes(x = rp, y = dev, colour = is_sig)) +
    geom_point() +
    scale_color_manual(values = friendly_pals$wong_eight[c(1:2)]) +
    theme_classic() +
    theme(text = element_text(family = "Arial"),
          legend.position = "inside",
          legend.position.inside = c(.85, .8)) +
    labs(colour = "Significant") +
    xlab("Relative Position") +
    ylab("Deviance") + 
    ggtitle(paste0(subtype_print_names(subtype), ": ", pop1, ", ", pop2))
  return(p)
}

for(i in 1:dim(pop_combs)[1]){
  pop1 <- pop_combs[i,1]
  pop2 <- pop_combs[i,2]
  p <- pop_pop_analysis(pop_pop_dir, pop1, pop2, subtype, rps = c(-10:-1, 1:10)) +
    geom_hline(yintercept = qchisq(0.95, 3), color = "red", linetype = 2) 
  print(p)
}
```


### A > G

```{r}
subtype <- "AT_GC"

for(i in 1:dim(pop_combs)[1]){
  pop1 <- pop_combs[i,1]
  pop2 <- pop_combs[i,2]
  p <- pop_pop_analysis(pop_pop_dir, pop1, pop2, subtype, rps = c(-10:-1, 1:10)) +
    geom_hline(yintercept = qchisq(0.95, 3), color = "red", linetype = 2) 
  print(p)
}
```

### A > T

```{r}
subtype <- "AT_TA"

for(i in 1:dim(pop_combs)[1]){
  pop1 <- pop_combs[i,1]
  pop2 <- pop_combs[i,2]
  p <- pop_pop_analysis(pop_pop_dir, pop1, pop2, subtype, rps = c(-10:-1, 1:10)) +
    geom_hline(yintercept = qchisq(0.95, 3), color = "red", linetype = 2) 
  print(p)
}
```

### C > T

```{r}
subtype <- "GC_AT"

for(i in 1:dim(pop_combs)[1]){
  pop1 <- pop_combs[i,1]
  pop2 <- pop_combs[i,2]
  p <- pop_pop_analysis(pop_pop_dir, pop1, pop2, subtype, rps = c(-10:-1, 1:10)) +
    geom_hline(yintercept = qchisq(0.95, 3), color = "red", linetype = 2) 
  print(p)
}
```

### C > A

```{r}
subtype <- "GC_TA"

for(i in 1:dim(pop_combs)[1]){
  pop1 <- pop_combs[i,1]
  pop2 <- pop_combs[i,2]
  p <- pop_pop_analysis(pop_pop_dir, pop1, pop2, subtype, rps = c(-10:-1, 1:10)) +
    geom_hline(yintercept = qchisq(0.95, 3), color = "red", linetype = 2) 
  print(p)
}
```

### C > G

```{r}
subtype <- "GC_CG"

for(i in 1:dim(pop_combs)[1]){
  pop1 <- pop_combs[i,1]
  pop2 <- pop_combs[i,2]
  p <- pop_pop_analysis(pop_pop_dir, pop1, pop2, subtype, rps = c(-10:-1, 1:10)) +
    geom_hline(yintercept = qchisq(0.95, 3), color = "red", linetype = 2) 
  print(p)
}
```

### CpG > TpG

```{r}
subtype <- "GC_AT"

for(i in 1:dim(pop_combs)[1]){
  pop1 <- pop_combs[i,1]
  pop2 <- pop_combs[i,2]
  p <- pop_pop_analysis(pop_pop_dir, pop1, pop2, subtype, rps = c(-10:-1, 2:10)) +
    geom_hline(yintercept = qchisq(0.95, 3), color = "red", linetype = 2) 
  print(p)
}
```

### CpG > ApG

```{r}
subtype <- "GC_TA"

for(i in 1:dim(pop_combs)[1]){
  pop1 <- pop_combs[i,1]
  pop2 <- pop_combs[i,2]
  p <- pop_pop_analysis(pop_pop_dir, pop1, pop2, subtype, rps = c(-10:-1, 2:10)) +
    geom_hline(yintercept = qchisq(0.95, 3), color = "red", linetype = 2) 
  print(p)
}
```

### CpG > GpG

```{r}
subtype <- "GC_CG"

for(i in 1:dim(pop_combs)[1]){
  pop1 <- pop_combs[i,1]
  pop2 <- pop_combs[i,2]
  p <- pop_pop_analysis(pop_pop_dir, pop1, pop2, subtype, rps = c(-10:-1, 2:10)) +
    geom_hline(yintercept = qchisq(0.95, 3), color = "red", linetype = 2) 
  print(p)
}
```

## Two Position Models

### Functions

```{r}
tp_all_dev <- function(two_pos_dir, subtype){
  pops <- c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS")
  results <- tp_deviance_df_load(two_pos_dir, pops[1], subtype) %>%
    select(rp1, rp2, dev, re) %>%
    mutate(pop = pops[1])
  for(i in 2:length(pops)){
    results <- results %>%
      bind_rows({
        tp_deviance_df_load(two_pos_dir, pops[i], subtype) %>%
          select(rp1, rp2, dev, re) %>%
          mutate(pop = pops[i])
      })
  }
  results <- results %>% distinct(rp1, rp2, pop, .keep_all = TRUE) %>%
    mutate(pop = factor(pop, levels = c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS")))
  return(results)
}

tp_re_cor_plot <- function(df_tp, subtype, method="pearson"){
  cor_obj <- df_tp %>%
    select(-dev) %>%
    pivot_wider(names_from = pop, values_from = re, id_cols = c(rp1, rp2)) %>%
    select(ALL:SAS) %>%
    corrr::correlate(method = method) %>%
    corrr::shave()
  
  p <- cor_obj %>% reshape2::melt() %>%
    mutate(term = factor(term, levels = c("ALL", "AFR", "AMR", "EAS", "EUR", "SAS"))) %>%
    filter(variable != term) %>%
    filter(term != "ALL", variable != "SAS") %>%
    mutate(round_val = round(value, 2)) %>%
    ggplot(aes(x=term, y=variable, fill = value)) +
    geom_tile() +
    scale_fill_distiller(palette = "Reds", na.value = "white", direction = 1, limits = c(0,1)) +
    theme_classic() +
    xlab("") +
    ylab("") +
    geom_text(aes(label=round_val)) +
    ggtitle(subtype_print_names(subtype))

  return(p)
}
```

### Get table for all pairs of populations

```{r}
two_pos_resid_table <- function(two_pos_dir){
  subtypes <- c("AT_CG", "AT_GC", "AT_TA",
                "GC_AT", "GC_TA", "GC_CG",
                "cpg_GC_AT", "cpg_GC_TA", "cpg_GC_CG")
  
  cor_types <- c("pearson", "spearman")
  
  pops <- c("AFR", "AMR", "EAS", "EUR", "SAS")
  pop_combs <- combn(pops,2)
  pops_df <- data.frame(pop1 = pop_combs[1,],
                        pop2 = pop_combs[2,])
  
  final <- data.frame(subtype = character(0), 
                      res_type = character(0),
                      pop1 = character(0),
                      pop2 = character(0),
                      value = numeric(0))
  
  for(st in subtypes){
    df_res <- tp_all_dev(two_pos_dir, st)
    
    for(i in 1:length(pops_df$pop1)){
      pop1 <- pops_df$pop1[i]
      pop2 <- pops_df$pop2[i]
      df_res2 <- df_res %>%
        filter(pop == pop1 | pop == pop2) %>%
        select(rp1, rp2, re, pop)
      
      for(ct in cor_types){
        # All positions
        value <- df_res2 %>%
          pivot_wider(id_cols = c("rp1", "rp2"), names_from = "pop", values_from = re) %>%
          {cor(.[,3], .[,4], method = ct)} %>%
          as.numeric()
        final <- bind_rows(final, 
                           data.frame(subtype = st, 
                                      res_type = ct, 
                                      pop1 = pop1, 
                                      pop2=pop2, 
                                      value = value))
      }
    }
  }
  return(final)
}

df_tp_cor <- two_pos_resid_table(two_pos_dir)

write_csv(df_tp_cor, "output/two_pos_pop_cor.csv")

df_tp_cor |> 
  tbl_summary(include = value,
              by = res_type,
              statistic = all_continuous() ~ "{min}-{max} ({mean})")

df_tp_cor |> 
  pivot_wider(names_from = res_type, values_from = value) |>
  tbl_summary(include = c(pearson, spearman), by = subtype,
              statistic = all_continuous() ~ "{min}-{max} ({mean})")

```


### A > C

```{r, warning=FALSE, message=FALSE}
subtype <- "AT_CG"

df_tp <- tp_all_dev(two_pos_dir, subtype)
tp_re_cor_plot(df_tp, subtype)
tp_re_cor_plot(df_tp, subtype, "spearman")
```

### A > G

```{r, warning=FALSE, message=FALSE}
subtype <- "AT_GC"

df_tp <- tp_all_dev(two_pos_dir, subtype)
tp_re_cor_plot(df_tp, subtype)
tp_re_cor_plot(df_tp, subtype, "spearman")
```

### A > T

```{r, warning=FALSE, message=FALSE}
subtype <- "AT_TA"

df_tp <- tp_all_dev(two_pos_dir, subtype)
tp_re_cor_plot(df_tp, subtype)
tp_re_cor_plot(df_tp, subtype, "spearman")
```

### C > T

```{r, warning=FALSE, message=FALSE}
subtype <- "GC_AT"

df_tp <- tp_all_dev(two_pos_dir, subtype)
tp_re_cor_plot(df_tp, subtype)
tp_re_cor_plot(df_tp, subtype, "spearman")
```

### C > A

```{r, warning=FALSE, message=FALSE}
subtype <- "GC_TA"

df_tp <- tp_all_dev(two_pos_dir, subtype)
tp_re_cor_plot(df_tp, subtype)
tp_re_cor_plot(df_tp, subtype, "spearman")
```

### C > G

```{r, warning=FALSE, message=FALSE}
subtype <- "GC_CG"

df_tp <- tp_all_dev(two_pos_dir, subtype)
tp_re_cor_plot(df_tp, subtype)
tp_re_cor_plot(df_tp, subtype, "spearman")
```

### CpG > TpG

```{r, warning=FALSE, message=FALSE}
subtype <- "cpg_GC_AT"

df_tp <- tp_all_dev(two_pos_dir, subtype)
tp_re_cor_plot(df_tp, subtype)
tp_re_cor_plot(df_tp, subtype, "spearman")
```

### CpG > ApG

```{r, warning=FALSE, message=FALSE}
subtype <- "cpg_GC_TA"

df_tp <- tp_all_dev(two_pos_dir, subtype)
tp_re_cor_plot(df_tp, subtype)
tp_re_cor_plot(df_tp, subtype, "spearman")
```

### CpG > GpG

```{r, warning=FALSE, message=FALSE}
subtype <- "cpg_GC_CG"

df_tp <- tp_all_dev(two_pos_dir, subtype)
tp_re_cor_plot(df_tp, subtype)
tp_re_cor_plot(df_tp, subtype, "spearman")
```
